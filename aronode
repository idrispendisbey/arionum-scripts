#!/bin/bash
#
# A useful script for managing an Arionum testnet and/or mainnet node.
# For more information see http://www.arionum.com
#
# Github: https://github.com/KyleFromOhio/arionum-scripts
# Docs:   http://www.aro.wiki
# Example: bash aronode mainnet install
usage() {
    echo "USAGE: "
    echo "  $ aronode <testnet|mainnet> <install|upgrade|reset|restart|status|...>"
    echo "  install    -- install Arionum node and services from scratch"
    echo "  upgrade    -- upgrade all node/server software; php/myql/nginx/packages/node"
    echo "  update     -- upgrade Arionum node & aronode code; ie. git pull"
    echo "  remove     -- purge nginx, php-fpm, mysql AND arionum content"
    echo "    additional options ..."
    echo "  backup     -- will dump essential tables to a gzipped sql file"
    echo "  import     -- will import a gzipped .sql file; 3rd argument (optional): <filename.sql.gz>"
    echo "  change     -- change hostname ip/domain that peers see you as"
    echo "  diff       -- view changes/code updates of Aronode's main repository"
    echo "  firewall   -- configure UFW firewall. 3rd argument: <install|on|off|remove>"
    echo "  fix        -- runs through some breaking change fix functions eg. fix020()"
    echo "  mysql      -- update my.cnf file. Arguments: <get|set|restart> <setting_name> <value>"
    echo "  peers      -- clear peers table. Arguments: <reset>"
    echo "  pop        -- fix stuck syncing; 3rd argument: <integer> of blocks to delete"
    echo "  rebuild    -- empty db; download remote .sql dump; import chain data; 3rd arg (optional): <latest>"
    echo "  require    -- install aronode script requirements"
    echo "  reset      -- set Aronode environment config to testnet or mainnet; then rebuild blockchain"
    echo "  restart    -- restart all Arionum related services; php/nginx/mysql"
    echo "  resync-accounts -- check ALL account balances table; time consuming."
    echo "  stop       -- stop public facing Arionum related services; php/nginx"
    echo "  status     -- check status of services"
    echo "  sync       -- runs sanity.php manually so you can monitor the sync; CTRL+C to kill"

}


# DEBUG: prevent chaos; halt on error
#set -e

# VARIABLES
ERROR=false
ERROR_CHAR="  ⌦  ERROR->"
CHECK_CHAR="  √"
INFO_CHAR="    INFO:"
TASK_CHAR="  ▷ TASK:"
LOG_CHAR="     LOG:"
BLANK_CHAR="   "

DOMAIN=""
DOMAINFOUND="unknown"
WEBROOT="/var/www"
SECUREOWNER="nobody"
WEBOWNER="www-data"
WEBGROUP="www-data"

ARONODE_PATH="/root/scripts"

WEBCONFIGFILE="config.inc.php"
WEBCONFIGFILESAMPLE="config-sample.inc.php"
WEBCONFIGPATH="include/config.inc.php"
WEBCONFIGPATHSAMPLE="include/config-sample.inc.php"
WEBCONFIGPATHBACKUP="include/config-backup.inc.php"

DBNAME="aronode"
DBUSER="aronode"
DBUSER_PASS=""
DBROOT_PASS=""
MYCNF_PATH="/root/.my.cnf"
MYSQL_CONFIG_PATH="/etc/mysql/my.cnf"

# import variables
BACKUP_FILENAME="aronode_dump"
# backup only backs up these tables
BLOCKCHAIN_TABLES="blocks accounts transactions mempool masternode"

# used in rebuild function; to re-download just delete LOCAL_SNAPSHOT
LOCAL_SNAPSHOT="arionum-daily.sql.gz"
LOCAL_SNAPTEMP="arionum-daily.sql"
REMOTE_SNAPSHOT="https://aro.pxgamer.xyz/daily/daily.sql.gz"

PACKAGES_GENERAL="git pigz dirmngr bc vim-nox htop ncdu cpulimit curl tar gzip wget zip unzip pv"
PHPv="7.3"
PHPFPM_SERVICE="php$PHPv-fpm"
PACKAGES_PHP="php$PHPv-cli php$PHPv-curl php$PHPv-mysql php$PHPv-mbstring php$PHPv-common php$PHPv-bcmath php$PHPv-gmp php$PHPv-gd php$PHPv-fpm"

DATER=`date +%Y%m%d`
TIMESTAMPER=`date '+%Y-%m-%d %H:%M:%S'`
LOG_FILE="$ARONODE_PATH/aronode_$DATER.log"

VHOSTS=()
# detect all folders in WEBDIR
while IFS= read -d $'\0' -r VHOST ; do
    VHOSTS=("${VHOSTS[@]}" "$VHOST")
done < <(find $WEBROOT -maxdepth 1 -mindepth 1 -type d -print0)

# Setup logging
END_LOG_MSG=""
startLogging(){
    exec > >(tee -ia $LOG_FILE)
    exec 2>&1
    echo "$TIMESTAMPER: start log"
    END_LOG_MSG="$INFO_CHAR output logged to $LOG_FILE"
}


export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LANGUAGE=en_US.UTF-8

# Adding LC_ALL LANG and LANGUAGE to user profile
if [[ -f ~/.profile && ! "$(grep "en_US.UTF-8" ~/.profile)" ]]; then
    { echo "LC_ALL=en_US.UTF-8";  echo "LANG=en_US.UTF-8";  echo "LANGUAGE=en_US.UTF-8"; } >> ~/.profile
elif [[ -f ~/.bash_profile && ! "$(grep "en_US.UTF-8" ~/.bash_profile)" ]]; then
    { echo "LC_ALL=en_US.UTF-8";  echo "LANG=en_US.UTF-8";  echo "LANGUAGE=en_US.UTF-8"; } >> ~/.bash_profile
fi

# For root user only
if [[ $EUID -ne 0 ]]; then
    echo "$ERROR_CHAR aronode must be run as root user. Type first: sudo su -"
    ERROR=true
fi

UNAME=$(uname)-$(uname -m) # Linux-x86_64
OS_DISTRO=`lsb_release -i -s` # Ubuntu
OS_VERSION=`lsb_release -r -s` # 16.04
OS_NAME=`lsb_release -c -s` # xenial


# Only tested on these OS
if [ "$OS_DISTRO" != "Ubuntu" ]; then
    echo "$ERROR_CHAR Script is written for Ubuntu xenial/bionic LTS only. Wrong operating system."
    ERROR=true
fi
if [[
    "$OS_NAME" != "xenial" &&
    "$OS_NAME" != "bionic"
]]; then
    echo "$ERROR_CHAR Script is written for Ubuntu xenial/bionic LTS only. Wrong operating system."
    ERROR=true
fi

# Get version of aronode script
VERSION_ARONODE="0.1.0"
aronodeCheckVersion() {
    if [ -f $ARONODE_PATH/VERSION ]; then
        VERSION_ARONODE=`cat $ARONODE_PATH/VERSION`
    fi
    DATER=`date`
    echo -e "$INFO_CHAR Aronode Script v$VERSION_ARONODE "
    echo -e "$INFO_CHAR $DATER"
}
aronodeCheckVersion

# GET 1st argument: testnet | mainnet
ARG_CONFIG_MODE=$1
if [ -z "$ARG_CONFIG_MODE" ]; then
    ARG_CONFIG_MODE="unknown"
fi
# allow help command
case "$ARG_CONFIG_MODE" in
    usage|help|h|-h|--help)
        usage
        exit 0
    ;;
    version)
        echo -e "$INFO_CHAR Aronode v$VERSION_ARONODE"
        exit 0
    ;;
esac
# if not help then only other option is testnet|mainnet
if [[ -z "$ARG_CONFIG_MODE" || ( "$ARG_CONFIG_MODE" != "testnet" && "$ARG_CONFIG_MODE" != "mainnet" ) ]]; then
    echo "$ERROR_CHAR First argument must be either testnet or mainnet."
    ERROR=true
fi

# GET 2nd argument: install | upgrade | remove
ARG_CALL=""
if [[ -z "2" || (
    "$2" != "backup" &&
    "$2" != "change" &&
    "$2" != "diff" &&
    "$2" != "firewall" &&
    "$2" != "fix" &&
    "$2" != "install" &&
    "$2" != "import" &&
    "$2" != "mysql" &&
    "$2" != "peers" &&
    "$2" != "pop" &&
    "$2" != "rebuild" &&
    "$2" != "remove" &&
    "$2" != "require" &&
    "$2" != "reset" &&
    "$2" != "restart" &&
    "$2" != "resync-accounts" &&
    "$2" != "stop" &&
    "$2" != "status" &&
    "$2" != "sync" &&
    "$2" != "upgrade" &&
    "$2" != "update" &&
    "$2" != "version"
    ) ]]; then
    echo "$ERROR_CHAR Second argument is invalid."
    ERROR=true
else
    ARG_CALL="$2"
fi

# DEBUG: print variables
# ( set -o posix ; set ) | cat; exit 1;

exitAsError() {
    sleep 1
    exit 1 # halt script with 1 error
}

# EXIT the script if there's error
if [ $ERROR == true ]; then
    usage
    exitAsError
fi


# FUNCTIONS



# check if testnet or mainnet
nodeCheckConfigMode() {
    #nodeFindDomainRoot
    NODE_CONFIG_MODE="unknown"
    if [[ -d "$DOMAINROOT" && -f "$DOMAINROOT/$WEBCONFIGPATH" ]]; then
        # Determine if testnet or mainnet
        CHECK_CONFIG=$(grep -Po "(?<=$_config\['testnet'\])[^;]*" "${DOMAINROOT}/$WEBCONFIGPATH")
        # trim = and spaces
        CHECK_CONFIG=$(echo -e "${CHECK_CONFIG//=}")
        CHECK_CONFIG=$(echo -e "${CHECK_CONFIG}" | tr -d '[:space:]')

        if [[ "$CHECK_CONFIG" == "false" ]]; then
            NODE_CONFIG_MODE="mainnet"
        fi
        if [[ "$CHECK_CONFIG" == "true" ]]; then
            NODE_CONFIG_MODE="testnet"
        fi
    fi
    echo "$INFO_CHAR Network: $NODE_CONFIG_MODE"

}



generatePassword() {
    PASS_LENGTH=16
    echo $(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w $PASS_LENGTH | head -n 1)
}

# find something like /var/www/mydomain.com
nodeFindDomainRoot() {

    DOMAINROOT="unknown"
    if [ -d "$WEBROOT" ]; then
        DOMAINROOT=$(find "$WEBROOT" -name "$WEBCONFIGFILE" | sed "s~/$WEBCONFIGPATH~~" | tail -n 1)
    fi
    # 2nd try if no custom config yet
    if [ -f "$DOMAINROOT/$WEBCONFIGPATHSAMPLE" ]; then
        DOMAINROOT=$(find "$WEBROOT" -name "$WEBCONFIGFILESAMPLE" | sed "s~/$WEBCONFIGPATHSAMPLE~~" | tail -n 1)
    fi
    if [ "$DOMAINROOT" == "" ]; then
        DOMAINROOT="unknown"
    fi
    echo "$INFO_CHAR Webroot: $DOMAINROOT"
    DOMAINFOUND=$(basename "$DOMAINROOT")
}

# apt upgrade
serverUpgrade() {
    echo "$TASK_CHAR Updating server packages and installing required tools ..."

    # backup my.cnf
    if [ -f "/etc/mysql/my.cnf" ]; then
        cp /etc/mysql/my.cnf /etc/mysql/my.cnf-BACKUP;
    fi

    export DEBIAN_FRONTEND=noninteractive
    add-apt-repository universe -y
    apt-get -qq update && apt-get -qq dist-upgrade -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" && apt-get -qq autoremove -y
    packageInstallGeneral
    echo "$CHECK_CHAR Packages updated."

    # apply any fixes

    # delete vhost defaults (if any)
    fix021

    # set/fix mysql config
    mysqlOptimizeConfig

}


# check php version
checkPhpVersion() {
    PHP_VERSION_CLI=$(php -v | head -n1 | cut -d" " -f2 | cut -c1-3)
}
# upgrade php version
packageUpgradePhp() {
    checkPhpVersion
    # upgrade php fpm and vhost from 7.2 to $PHPv
    if [ "$PHP_VERSION_CLI" == "7.2" ]; then
        echo "$TASK_CHAR Upgrading PHP 7.2 to $PHPv ..."
        # stop services
        systemctl stop nginx
        systemctl stop php7.2-fpm
        # disable 7.2 service
        systemctl disable php7.2-fpm
        # install new php packages
        packageInstallPhp
        # enable/start new php fpm service
        systemctl enable $PHPFPM_SERVICE
        # make sure fix v0.2.0 is run first
        fix020

        # find arionum vhosts and update config to use new php version
        for KEY in "${!VHOSTS[@]}";
        do
            DIR_NAME=${VHOSTS[$KEY]}
            THISWEBNAME=$(basename $DIR_NAME)
            # update vhost
            THISVHOST="/etc/nginx/conf.d/$THISWEBNAME.conf"
            sed -i "s/php7.2-fpm/php$PHPv-fpm/g" $THISVHOST
            echo "$CHECK_CHAR Vhost updated: $THISVHOST"
        done
        # check ok?
        nginx -t

        # restart nginx and php fpm
        nodeStart
    fi
}

# create tmp/db-update for code to do a db update
flagDbUpdate(){
    #nodeFindDomainRoot
    if [ "$DOMAINROOT" != "unknown" ]; then
        PWD=`pwd`
        cd $DOMAINROOT
        touch tmp/db-update
        chown $WEBOWNER:$WEBGROUP tmp/db-update
        chmod 775 tmp/db-update
        echo "$CHECK_CHAR Database flagged for an update."
        cd $PWD
    else
        echo "$ERROR_CHAR flagDbUpdate() Could not locate Arionum node software in '$DOMAINROOT'"
        exitAsError
    fi
}

# delete tmp/sanity-lock if exists
removeSanityLock(){
    #nodeFindDomainRoot
    if [ "$DOMAINROOT" != "unknown" ]; then
        PWD=`pwd`
        cd $DOMAINROOT
        if [ -f $DOMAINROOT/tmp/sanity-lock ]; then
            rm $DOMAINROOT/tmp/sanity-lock
            echo "$CHECK_CHAR sanity-lock removed."
        fi
        cd $PWD
    else
        echo "$ERROR_CHAR removeSanityLock() Could not locate Arionum node software in '$DOMAINROOT'"
        exitAsError
    fi

}

# fix perms in $DOMAINROOT
fixNodePermissions() {
    #nodeFindDomainRoot
    echo "$TASK_CHAR Setting permissions..."
    if [ "$DOMAINROOT" != "unknown" ]; then
        PWD=`pwd`
        cd $DOMAINROOT
        chown -R $SECUREOWNER $DOMAINROOT/*
        chown -R $SECUREOWNER $DOMAINROOT/.[^.]*
        chgrp -R $WEBGROUP $DOMAINROOT/*
        chgrp -R $WEBGROUP $DOMAINROOT/.[^.]*
        if [ -d $DOMAINROOT/tmp ]; then
            chmod 775 -R $DOMAINROOT/tmp
            chown -R $WEBOWNER $DOMAINROOT/tmp/*
        fi
        if [ -f $DOMAINROOT/tmp/db-update ]; then
            chmod 775 -R $DOMAINROOT/tmp/db-update
        fi
        echo "$CHECK_CHAR Permissions set."
        cd $PWD
    else
        echo "$ERROR_CHAR fixNodePermissions() Could not locate Arionum node software in '$DOMAINROOT'"
        exitAsError
    fi
}

nodeRestart() {
    nodeStop # stop nginx and php-fpm
    nodeStopDb # stop mysql
    nodeStart # start all
}
# stop nginx and php-fpm
nodeStop() {
    echo "$TASK_CHAR Stopping Nginx, PHP ..."
    killSanity

    upNginx
    if [ "$UP_NGINX" == "yes" ]; then
        service nginx stop
    fi
    upPhp
    if [ "$UP_PHP" == "yes" ]; then
        service $PHPFPM_SERVICE stop
    fi
}
# stop mysql
nodeStopDb() {
    echo "$TASK_CHAR Stopping Mysql ..."
    upMysql
    if [ "$UP_MYSQL" == "yes" ]; then
        service mysql stop
    fi
}
# start nginx, php-fpm, mysql (if not running)
nodeStart() {

    # BUG: check if my.cnf is missing OR is symlink; if so attempt restore to default
    mysqlFixConfig

    service $PHPFPM_SERVICE start
    service nginx start
    service mysql start

    # check for errors
    upMysql
    upNginx
    upPhp
    if [ "$UP_NGINX" == "no" ]; then
        echo "$ERROR_CHAR nodeStart() nginx service failed. Check nginx logs in /var/log/";
        exitAsError
    else
        echo "$CHECK_CHAR   nginx: started."
    fi
    if [ "$UP_PHP" == "no" ]; then
        echo "$ERROR_CHAR nodeStart() php-fpm service failed. Check php-fpm logs in /var/log/";
        exitAsError
    else
        echo "$CHECK_CHAR php fpm: started."
    fi
    if [ "$UP_MYSQL" == "no" ]; then
        echo "$ERROR_CHAR nodeStart() mysql service failed. Check mysql logs in /var/log/";
        exitAsError
    else
        echo "$CHECK_CHAR   mysql: started."
    fi
}


nodeRefresh() {
    echo "$TASK_CHAR Refreshing node ..."
    # documentation states to load node twice
    curl -sSL -o /dev/null http://127.0.0.1:80/ 2>&1
    curl -sSL -o /dev/null http://127.0.0.1:80/ 2>&1
    curl -sSL -o /dev/null http://127.0.0.1:80/ 2>&1
    echo "$CHECK_CHAR Node refreshed."
}

# check if mysql is up; NOTE: 0=true(no failures); 1=failure
upMysql() {
    CMD="mysql";
    UP=$(pgrep "$CMD" | wc -l);
    UP_MYSQL="yes";
    if [ $UP -eq 0 ]; then UP_MYSQL="no"; fi
}
# check if php-fpm is up; NOTE: 0=true(no failures); 1=failure
upPhp() {
    CMD="php-fpm";
    UP=$(pgrep "$CMD" | wc -l);
    UP_PHP="yes";
    if [ $UP -eq 0 ]; then UP_PHP="no"; fi
}
# check if nginx is up; NOTE: 0=true(no failures); 1=failure
upNginx() {
    CMD="nginx";
    UP=$(pgrep "$CMD" | wc -l);
    UP_NGINX="yes";
    if [ $UP -eq 0 ]; then UP_NGINX="no"; fi
}
# check if ntp is up; NOTE: 0=true(no failures); 1=failure
upNtp() {
    CMD="ntp";
    UP=$(pgrep "$CMD" | wc -l);
    UP_NTP="yes";
    if [ $UP -eq 0 ]; then UP_NTP="no"; fi
}
# check if ufw is up; NOTE: 0=true(no failures); 1=failure
upUfw() {
    UP=$(ufw status | grep active | wc -l);
    UP_UFW="yes";
    if [ $UP -eq 0 ]; then UP_UFW="no"; fi
}

packageInstallNginx(){
    echo "$TASK_CHAR packageInstallNginx() Installing Nginx ..."

    upNginx
    if [ "$UP_NGINX" == "no" ]; then
        PWD=`pwd`
        cd /tmp/ && wget -O nginx_signing.key http://nginx.org/keys/nginx_signing.key
        apt-key add nginx_signing.key
        sh -c "echo 'deb http://nginx.org/packages/mainline/ubuntu/ '$(lsb_release -cs)' nginx' > /etc/apt/sources.list.d/nginx.list"
        add-apt-repository ppa:ondrej/nginx-mainline -y
        apt-get -qq update -y
        apt-get -qq install nginx -y
        service nginx restart
        cd $PWD
    else
        echo "$INFO_CHAR Nginx detected as running already.";
    fi

    #  check if nginx installed and running
    upNginx
    if [ "$UP_NGINX" == "no" ]; then
        echo "$ERROR_CHAR packageInstallNginx() failed to start nginx service.";
        exitAsError
    else
        echo "$CHECK_CHAR Nginx is installed and running."
    fi
}
packageInstallPhp(){
    echo "$TASK_CHAR packageInstallPhp() Installing PHP $PHPv and required modules ..."

    apt-get -qq install software-properties-common -y
    if [ $OS_NAME == "xenial" ]; then
        apt-get -qq install python-software-properties -y
    fi

    upPhp
    if [ "$UP_PHP" == "no" ]; then
        add-apt-repository ppa:ondrej/php -y
        apt-get -qq update -y
        apt-get -qq install $PACKAGES_PHP -y
    else
        echo "$INFO_CHAR php-fpm detected as running already.";
    fi

    # check if php-fpm installed and running
    upPhp
    if [ "$UP_PHP" == "no" ]; then
        echo "$ERROR_CHAR packageInstallPhp() failed to start php-fpm service.";
        exitAsError
    else
        echo "$CHECK_CHAR PHP FPM $PHPv is installed and running."
    fi
}
mysqlOptimizeConfig(){
    if [ -f "$MYSQL_CONFIG_PATH" ]; then
        # up max connections
        MYSQL_VARIABLE="max_connections"
        MYSQL_VALUE=1000
        mysqlSetConfig
    fi
}
mysqlFixConfig(){
    # BuG: if apt upgrade broke config; fix it
    if [[ -f "/etc/mysql/my.cnf.dpkg-new" && ! -e "$MYSQL_CONFIG_PATH" ]]; then
        # remove symlink
        if [ -L "$MYSQL_CONFIG_PATH" ]; then
            unlink $MYSQL_CONFIG_PATH;
        fi
        # copy backup config OR new config
        cp /etc/mysql/my.cnf.dpkg-new $MYSQL_CONFIG_PATH;
        mysqlOptimizeConfig
    fi
}
mysqlGetConfig(){
    if [ -z "$MYSQL_VARIABLE" ]; then
        echo "$ERROR_CHAR invalid request. missing mysql variable argument.";
        return 0
    fi
    MYSQL_VALUE=$(awk -F "=" "/$MYSQL_VARIABLE/ {print \$2}" $MYSQL_CONFIG_PATH | tr -d ' ')
    if [ -z "$MYSQL_VALUE" ]; then
        echo "$ERROR_CHAR mysql variable not found in $MYSQL_CONFIG_PATH";
        return 0
    else
        echo "$CHECK_CHAR Variable Found: $MYSQL_VARIABLE = $MYSQL_VALUE in $MYSQL_CONFIG_PATH";
    fi
}
mysqlGetRootCnfPass(){
    MYCNF_ROOTPASS=""
    if [ -f "$MYCNF_PATH" ]; then
        MYCNF_ROOTPASS=$(awk -F "=" "/password=/ {print \$2}" $MYCNF_PATH | tr -d ' ')
    fi
}
mysqlSetConfig(){
    if [ -z "$MYSQL_VARIABLE" ]; then
        echo "$ERROR_CHAR invalid command. mysql variable not defined";
        return 0
    fi
    if [ -z "$MYSQL_VALUE" ]; then
        echo "$ERROR_CHAR invalid command mysql value not defined";
        return 0
    fi
    if [ -f "$MYSQL_CONFIG_PATH" ]; then
        sed -i "s/^\($MYSQL_VARIABLE\s*=\s*\).*\$/\1$MYSQL_VALUE/" $MYSQL_CONFIG_PATH;
        echo "$INFO_CHAR set mysql variable $MYSQL_VARIABLE to $MYSQL_VALUE in $MYSQL_CONFIG_PATH";

    fi
}
packageInstallMysql(){
    echo "$TASK_CHAR packageInstallMysql() Installing Mysql (MariaDB) ..."

    apt-get -qq install software-properties-common -y
    apt-get -qq install apt-transport-https -y

    upMysql
    if [ "$UP_MYSQL" == "no" ]; then
        #apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8
        #sh -c "echo 'deb [arch=amd64,i386] https://mirrors.evowise.com/mariadb/repo/10.2/ubuntu '$(lsb_release -cs)' main' > /etc/apt/sources.list.d/MariaDB-10.2.list"
        apt-get update -y
        # skip password prompt; will set later
        export DEBIAN_FRONTEND=noninteractive
        apt-get install mariadb-server mariadb-client -y

        # set/fix mysql config
        mysqlFixConfig
        mysqlOptimizeConfig
    else
        echo "$INFO_CHAR mysql detected as running already.";
    fi

    # check if marioadb installed and running
    upMysql
    if [ "$UP_MYSQL" == "no" ]; then
        echo "$ERROR_CHAR packageInstallMysql() failed to start mysql(mariadb) service.";
        exitAsError
    else
        echo "$CHECK_CHAR Mysql (MariaDB) is installed and running."
    fi
}
packagePurgeMysql() {
    echo "$TASK_CHAR packagePurgeMysql() Purging mysql ..."
    nodeStopDb
    apt-get -qq --purge remove mariadb-server mariadb-client -y
    apt-get -qq --purge remove mysql* -y
    rm -rf /var/lib/mysql
    rm -rf /var/log/mysql
    if [ -f "$MYCNF_PATH" ]; then
        rm "$MYCNF_PATH"
    fi

    apt-get -qq autoremove -y
    apt-get -qq autoclean -y
    echo "$CHECK_CHAR Mysql purged."
}

packageInstallNtp(){
    echo "$TASK_CHAR packageInstallNtp() Installing Ntp; Syncing server time to UTC ..."
    apt-get -qq install ntp ntpdate -yyq
    service ntp stop
    timedatectl set-timezone UTC
    service ntp stop
    ntpdate pool.ntp.org
    service ntp start
    # check if ntp installed and running and set to UTC
    upNtp
    if [ "$UP_NTP" == "no" ]; then
        echo "$ERROR_CHAR packageInstallNtp() failed to start ntp service.";
        exitAsError
    else
        echo "$CHECK_CHAR Date/Time updated."
    fi
}

packageInstallGeneral() {
    echo "$TASK_CHAR packageInstallGeneral() Installing required packages ..."
    add-apt-repository universe -y
    apt-get -qq install apt-transport-https -y
    apt-get -qq install $PACKAGES_GENERAL -y
    echo "$CHECK_CHAR Server packages installed."
}


setMysqlRootPass() {
    mysqlGetRootCnfPass
    if [ -f "$MYCNF_PATH" ]; then
        sudo -H mysql -e "GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY '${MYCNF_ROOTPASS}'";
        sudo -H mysql -e "GRANT ALL PRIVILEGES ON *.* TO 'root'@'127.0.0.1' IDENTIFIED BY '${MYCNF_ROOTPASS}'";
        sudo -H mysql -e "FLUSH PRIVILEGES;"
        echo "$CHECK_CHAR root pass set and stored in $MYCNF_PATH"
    fi
}
hardenMysql() {
    sudo -H mysql -e "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1');"
    sudo -H mysql -e "DELETE FROM mysql.user WHERE User='';"
    sudo -H mysql -e "DELETE FROM mysql.db WHERE Db='test' OR Db='test_%';"
    sudo -H mysql -e "FLUSH PRIVILEGES;"
    setMysqlRootPass
}

hardenPHP() {
    # TODO: php.ini, php-fpm conf
    return 0
}
hardenNginx() {
    # TODO: badbots, nginx.conf
    return 0
}
hardenSSH() {
    # TODO: ssh conf; change port; install fail2ban
    return 0
}
checkSshPort() {
    if [ -f /etc/ssh/sshd_config ]; then
        SSH_PORT=$(awk '/^\s*Port\s+([0-9]{2,5})/{print}' /etc/ssh/sshd_config | cut -d'#' -f1 | cut -d';' -f1| tr -dc '0-9')
    fi
    if [ "$SSH_PORT" == "" ]; then
        SSH_PORT=22
    fi
}
hardenNetwork() {
    # TODO: sysctl
    return 0
}
hardenFirewall() {
    echo "$TASK_CHAR hardenFirewall() Configuring UFW firewall ..."
    apt-get -qq install ufw -y
    service ufw restart
    # check if ufw installed and running
    upUfw
    if [ "$UP_UFW" == "no" ]; then
        echo "$ERROR_CHAR UFW firewall is not running.";
        exitAsError
    else
        checkSshPort

        ufw --force enable
        ufw allow proto udp to 0.0.0.0/0 port 123 # ntp
        ufw allow proto tcp to 0.0.0.0/0 port 22 # ssh
        ufw allow proto tcp to 0.0.0.0/0 port 2222 # alternative ssh
        if [ $SSH_PORT -gt 0 ]; then
            ufw allow proto tcp to 0.0.0.0/0 port $SSH_PORT
        fi
        ufw allow proto tcp to 0.0.0.0/0 port 80 # http web
        ufw allow proto tcp to 0.0.0.0/0 port 443 # https web
        ufw default deny incoming
        ufw default allow outgoing
        service ufw restart
        echo "$CHECK_CHAR UFW firewall configured."
    fi
    echo "$INFO_CHAR running # ufw status"
    ufw status

}

enableFirewall() {
    echo "$TASK_CHAR enableFirewall() Enabling UFW firewall ..."
    # check if ufw installed and running
    checkUfwInstalled
    upUfw
    if [ "$UP_UFW" == "no" ]; then
        echo "$ERROR_CHAR UFW firewall is not running.";
        exitAsError
    else
        ufw --force enable
        echo "$CHECK_CHAR UFW firewall enabled."
        echo "$INFO_CHAR running # ufw status"
        ufw status
    fi
}

disableFirewall() {
    echo "$TASK_CHAR disableFirewall() Disabling UFW firewall ..."
    # check if ufw installed and running
    checkUfwInstalled
    upUfw
    if [ "$UP_UFW" == "no" ]; then
        echo "$ERROR_CHAR UFW firewall is not running.";
        exit 1 # halt script with error
    else
        ufw disable
        echo "$CHECK_CHAR UFW firewall disabled."
    fi
}

removeFirewall() {
    echo "$TASK_CHAR removeFirewall() Removing UFW firewall ..."
    # check if ufw installed and running
    checkUfwInstalled
    upUfw
    if [ "$UP_UFW" == "yes" ]; then
        service ufw stop
    fi
    apt-get -qq --purge remove ufw -y
    echo "$CHECK_CHAR UFW firewall removed."
}

checkUfwInstalled() {
    installedUFW="$(type -p "ufw")"
    if [ ! installedUFW ]; then
        echo "$ERROR_CHAR UFW not installed. To install try 'apt install ufw' instead."
        exitAsError
    fi
}

setupMysqlDatabase(){
    echo "$TASK_CHAR Setting up mysql database..."
    # check if config exists; if so use
    if [ -f $MYCNF_PATH ]; then
        DBROOT_PASS=$(grep -Po "(?<=password=)[^;]*" "$MYCNF_PATH")
        DBUSER_PASS=$(grep -Po "(?<=aronode_pass=)[^;]*" "$MYCNF_PATH")
        echo "$INFO_CHAR database config found in $MYCNF_PATH"
    else
        # Generate new user password(s)
        DBROOT_PASS=$(generatePassword)
        DBUSER_PASS=$(generatePassword)

        # Reset root pass
        echo "$INFO_CHAR setting root pass."
        sudo -H mysql -e "GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY '${DBROOT_PASS}'";
        sudo -H mysql -e "GRANT ALL PRIVILEGES ON *.* TO 'root'@'127.0.0.1' IDENTIFIED BY '${DBROOT_PASS}'";
        echo "$INFO_CHAR root pass set."

        # Create, write to and save mysql config to .my.cnf file
        echo "$INFO_CHAR saving root pass to $MYCNF_PATH"
        touch $MYCNF_PATH
        chmod 0600 $MYCNF_PATH
        > $MYCNF_PATH
        echo "[client]" >> $MYCNF_PATH
        echo "user=root" >> $MYCNF_PATH
        echo "password=$DBROOT_PASS" >> $MYCNF_PATH
        echo "# aronode_user=$DBUSER" >> $MYCNF_PATH
        echo "# aronode_pass=$DBUSER_PASS" >> $MYCNF_PATH
        echo "$INFO_CHAR root pass saved to $MYCNF_PATH"
    fi

    # create db and user if not exists
    if [ -d /var/lib/mysql/$DBNAME ] ; then
        echo "$INFO_CHAR $DBNAME database already exists."
    else
        sudo -H mysql  -e "CREATE DATABASE ${DBNAME} /*\!40100 DEFAULT CHARACTER SET utf8 */;"
        echo "$TASK_CHAR create arionum database"
    fi
    USER_EXISTS="$(sudo -H mysql  -sse "SELECT EXISTS(SELECT 1 FROM mysql.user WHERE user = '$DBUSER')")"
    if [ "$USER_EXISTS" = 1 ]; then
        echo "$INFO_CHAR $DBUSER mysql user already exists."
    else
        echo "$TASK_CHAR create arionum database user"
        sudo -H mysql  -e "CREATE USER ${DBUSER}@localhost IDENTIFIED BY '${DBUSER_PASS}';"
        sudo -H mysql  -e "GRANT ALL PRIVILEGES ON ${DBNAME}.* TO '${DBUSER}'@'localhost';"
    fi
    # flush permissions
    sudo -H mysql  -e "FLUSH PRIVILEGES;"

    echo "$CHECK_CHAR Database setup finished."
}

setupNginxVhost() {
    echo "$TASK_CHAR Setting up default website in Nginx ..."

    # check if directories exists; create otherwise
    DIR="/etc/nginx/sites-enabled"
    if [ ! -d "$DIR" ]; then
        mkdir $DIR
    fi
    DIR="/etc/nginx/sites-available"
    if [ ! -d "$DIR" ]; then
        mkdir $DIR
    fi
    DOMAINROOT=$WEBROOT/$DOMAIN
    if [ ! -d $DOMAINROOT ]; then
        mkdir -p $DOMAINROOT
    fi

    # secure domain root
    PWD=`pwd`
    cd $DOMAINROOT
    chown $SECUREOWNER $WEBROOT
    chgrp $WEBGROUP $WEBROOT
    chmod 0755 $DOMAINROOT
    cd $PWD

    # update nginx user to WEBUSER:WEBGROUP:
    sed -i "s/user  nginx;/user  $WEBOWNER $WEBOWNER;/g" /etc/nginx/nginx.conf

    # delete vhost defaults
    fix021

    if [ ! -f $ARONODE_PATH/aronode.vhost ]; then
        echo "$ERROR_CHAR setupNginxVhost() $ARONODE_PATH/aronode.vhost not found. Check github, download it, try again.";
        exitAsError
    fi
    # enable vhost
    VHOST_PATH_AVAILABLE="/etc/nginx/conf.d/$DOMAIN.conf"
    cat $ARONODE_PATH/aronode.vhost > $VHOST_PATH_AVAILABLE
    sed -i "s/__DOMAIN__/$DOMAIN/g" $VHOST_PATH_AVAILABLE
    sed -i "s~__WEBROOT__~$WEBROOT~g" $VHOST_PATH_AVAILABLE
    sed -i "s/__PHPVERSION__/$PHPv/g" $VHOST_PATH_AVAILABLE
    if [ ! -L "$VHOST_PATH_ENABLED" ]; then
        ln -s $VHOST_PATH_AVAILABLE $VHOST_PATH_ENABLED
        echo "$CHECK_CHAR vhost setup in Nginx at $VHOST_PATH_AVAILABLE"
    fi

    service nginx restart

    #  check if nginx installed and running
    upNginx
    if [ "$UP_NGINX" == "no" ]; then
        echo "$ERROR_CHAR setupNginxVhost() failed to start nginx service. Bad vhost config?";
        exitAsError
    else
        echo "$CHECK_CHAR Nginx restarted and running."
    fi

}
# v0.2.0 changes: move old sites-enabled/*vhosts to /etc/nginx/conf.d/*conf
fix020(){
    echo "$TASK_CHAR Running fix for v0.2.0 ..."
    if [ -f /etc/nginx/conf.d/vhosts.conf ]; then
        rm /etc/nginx/conf.d/vhosts.conf
    fi
    if [ -L "/etc/nginx/sites-enabled/$DOMAINFOUND.vhost" ]; then
        unlink /etc/nginx/sites-enabled/$DOMAINFOUND.vhost
    fi
    if [ -f /etc/nginx/sites-available/$DOMAINFOUND.vhost ]; then
        mv /etc/nginx/sites-available/$DOMAINFOUND.vhost /etc/nginx/conf.d/$DOMAINFOUND.conf
        echo "$INFO_CHAR Fixed $DOMAINFOUND"
    fi
    echo "$CHECK_CHAR Fix v0.2.0 complete."
}
# v0.2.1 changes: delete every kind of default vhost you can find
fix021(){
    echo "$TASK_CHAR Running fix for v0.2.1 ..."
    # delete default vhost file(s)
    if [ -f /etc/nginx/conf.d/default.conf ]; then
        rm /etc/nginx/conf.d/default.conf
    fi
    # delete default vhost file(s)
    if [ -f /etc/nginx/conf.d/default ]; then
        rm /etc/nginx/conf.d/default
    fi
    if [ -f /etc/nginx/sites-enabled/default ]; then
        rm /etc/nginx/sites-enabled/default
    fi
    if [ -L /etc/nginx/sites-available/default ]; then
        unlink /etc/nginx/sites-available/default
    fi
    if [ -L /etc/nginx/sites-available/default.conf ]; then
        unlink /etc/nginx/sites-available/default.conf
    fi
    # delete old vhost config (if exists)
    if [ -f /etc/nginx/conf.d/vhosts.conf ]; then
        rm /etc/nginx/conf.d/vhosts.conf
    fi
    echo "$CHECK_CHAR Fix v0.2.1 complete."
}

gitInitNode() {
    echo "$TASK_CHAR Installing Arionum node software ..."

    if [[ -d "$DOMAINROOT" ]]; then
        PWD=`pwd`
        cd $DOMAINROOT
        # check git exists so it won't halt process on error
        if [[ ! -d .git ]]; then
            git init
            git remote add origin https://github.com/arionum/node.git
        fi

        git fetch --all --prune
        git checkout master
        git config core.fileMode false
        if [ ! -f "$DOMAINROOT/$WEBCONFIGPATH" ]; then
            cp -f $DOMAINROOT/$WEBCONFIGPATHSAMPLE $DOMAINROOT/$WEBCONFIGPATH
        fi
        echo "$CHECK_CHAR Download of Arionum node finished."
        cd $PWD
    else
        echo "$ERROR_CHAR gitInitNode() $DOMAINROOT path not found.";
        exitAsError
    fi
}
gitPullAronode() {

    PWD=`pwd`
    cd $ARONODE_PATH
    if [ -d .git ]; then
        echo "$TASK_CHAR Updating aronode script ..."
        git fetch --all
        git reset --hard origin/master
        chmod +x $ARONODE_PATH/aronode
        git config core.fileMode false
    fi
    cd $PWD
}
symlinkAronode() {
    if [[ -d /usr/local/bin && ! -L /usr/local/bin/aronode ]]; then
        echo "$TASK_CHAR Creating aronode symlink in /usr/local/bin/aronode ..."
        ln -s $ARONODE_PATH/aronode /usr/local/bin/aronode
    fi
}


setupNodeConfig() {
    echo "$TASK_CHAR Updating node database config..."
    #nodeFindDomainRoot
    ARONODE_CONFIG="$DOMAINROOT/$WEBCONFIGPATH"
    sed -i -r "s/(dbname=)([^']*)/\1$DBNAME/" $ARONODE_CONFIG
    sed -i -r "s/($_config\['db_user'\] = ')([^']*)/\1$DBUSER/" $ARONODE_CONFIG
    sed -i -r "s/($_config\['db_pass'\] = ')([^']*)/\1$DBUSER_PASS/" $ARONODE_CONFIG
    echo "$CHECK_CHAR Node config Updated."
}

nodeInstall() {

    # Intro
    echo ""
    echo "$INFO_CHAR Welcome to Arionum."
    echo "$INFO_CHAR An arionum node runs as a PHP website."
    echo "$INFO_CHAR This script will install & configure Nginx, Mysql, Php-fpm, and other required packages."
    echo "$INFO_CHAR It will configure a vhost in nginx, clone the arionum node repo, and setup the database."
    echo "$INFO_CHAR Get an Arionum mainnet (or testnet) node up and running in seconds!"
    echo "$INFO_CHAR Brought to you by KyleFromOhio and www.aro.wiki"

    # check RAM
    checkRAM
    if [[ "$ARG_CONFIG_MODE" == "mainnet" && $RAMTOTAL -lt 1800 ]]; then
        echo ""
        read -p "WARNING: Detected < 2GB RAM. Node may have issues syncing beyond block 10800. Continue? (yes|no): " USER_RAM_CONTINUE
        if ! [[ "$USER_RAM_CONTINUE" == "yes" ]]; then
            echo -e "$ERROR_CHAR You did not type 'yes'. Halting setup.\n"
            exitAsError
        fi
    fi

    # Prompt user for domain name
    echo ""
    echo "$INFO_CHAR You can access the node via the main server IP address. A domain name is optional."
    read -p "QUESTION: Enter a custom domain name (arionum.com): " DOMAIN
    if [[ "$DOMAIN" == "" ]]; then
        DOMAIN="arionum.com"
    fi
    # check DOMAIN is valid; [a-z0-9\-\.]; start and end with a letter; replace any capital letters with lowercase automatically.
    DOMAIN=`echo "$DOMAIN" | awk '{print tolower($0)}'`
    # strip www. from beginning
    DOMAIN=`echo "$DOMAIN" | sed -e "s/^www\.//"`
    REGEX="^[a-z][a-z0-9\.-]{1,252}[a-z\.]{2,24}$";
    if ! [[ "$DOMAIN" =~ $REGEX ]]; then
        echo "$ERROR_CHAR Invalid domain entered ..."
        exitAsError
    fi

    echo "$TASK_CHAR Starting Arionum node installation ..."
    echo "$INFO_CHAR     DOMAIN: $DOMAIN"

    serverUpgrade
    packageInstallNtp
    packageInstallGeneral
    packageInstallPhp
    packageInstallNginx
    packageInstallMysql
    setupMysqlDatabase
    setupNginxVhost

    # TODO: move these to own function/call?
    # run basic mysql security commands
    ####echo "$TASK_CHAR Hardening system ..."
    hardenMysql
    ####hardenPHP
    ####hardenNginx
    ####hardenSSH
    ####hardenNetwork
    ####hardenFirewall
    ####echo "$CHECK_CHAR System hardened."

    gitInitNode
    setupNodeConfig
    fixNodePermissions

    nodeStop
    if [[ "$ARG_CONFIG_MODE" == "testnet" ]]; then
        nodeTestnetConfig
    fi
    nodeStart
    nodeRefresh

    echo ""
    echo "$CHECK_CHAR Node Installation Complete."
    echo ""
    echo "$INFO_CHAR MySQL passwords available in: $MYCNF_PATH"
    echo "$INFO_CHAR Node installed to: $DOMAINROOT"
    echo "$INFO_CHAR Node config in: $DOMAINROOT/$WEBCONFIGPATH"
    echo "$INFO_CHAR Visit: http://YourIpAddressOrDomain/ OR http://127.0.0.1 locally and you should see current arionum block number."
    echo "$INFO_CHAR API Documentation: http://YourIpAddressOrDomain/doc/"
    echo "$INFO_CHAR API Endpoint: http://YourIpAddressOrDomain/api.php"
}

nodeUpdate() {
    echo "$TASK_CHAR Starting Arionum node update ..."

    echo "$INFO_CHAR Locating Arionum node installation directory ..."
    # detect path of node software; look for $WEBCONFIGPATH
    # nodeFindDomainRoot
    # cd to domain root path
    if [ -d $DOMAINROOT ]; then
        PWD=`pwd`
        cd $DOMAINROOT
        echo "$INFO_CHAR Installation directory found: $DOMAINROOT"
        echo "$INFO_CHAR Getting node updates from git ..."

        cp -f $DOMAINROOT/$WEBCONFIGPATH $DOMAINROOT/$WEBCONFIGPATHBACKUP
        git pull origin master
        git config core.fileMode false
        cp -f $DOMAINROOT/$WEBCONFIGPATHBACKUP $DOMAINROOT/$WEBCONFIGPATH

        echo "$CHECK_CHAR Node update complete."
        cd $PWD
    else
        echo "$ERROR_CHAR Arionum Node is not installed. Nothing to upgrade. Try install instead."
        exitAsError
    fi

}

nodeUpgrade() {
    echo "$TASK_CHAR Starting Arionum node upgrade ..."

    echo "$INFO_CHAR Upgrading server packages ..."
    serverUpgrade
    echo "$CHECK_CHAR Server packages updated."

    echo "$INFO_CHAR Locating Arionum node installation directory ..."
    # detect path of node software; look for $WEBCONFIGPATH
    # nodeFindDomainRoot
    # cd to domain root path
    if [ -d $DOMAINROOT ]; then
        PWD=`pwd`
        cd $DOMAINROOT
        echo "$INFO_CHAR Installation directory found: $DOMAINROOT"
        echo "$INFO_CHAR Getting node updates from git ..."

        cp -f $DOMAINROOT/$WEBCONFIGPATH $DOMAINROOT/$WEBCONFIGPATHBACKUP
        git pull origin master
        cp -f $DOMAINROOT/$WEBCONFIGPATHBACKUP $DOMAINROOT/$WEBCONFIGPATH

        echo "$CHECK_CHAR Node upgrade complete."
        cd $PWD
    else
        echo "$ERROR_CHAR Arionum Node is not installed. Nothing to upgrade. Try install instead."
        exitAsError
    fi

}

backupDb() {

    # install pigz if not installed
    if [ $(dpkg-query -W -f='${Status}' pigz 2>/dev/null | grep -c "ok installed") -eq 0 ];
    then
        apt-get -qq install pigz -y;
    fi

    echo "$TASK_CHAR exporting blockchain data (PLEASE WAIT) ..."
    # get estimated db size
    SIZE_BYTES=$(sudo -H mysql  <<< 'SELECT ROUND(SUM(data_length) * 0.60) AS "size_bytes" FROM information_schema.TABLES;' | tail -n1)

    # only backup blockchain table data
    sudo -H mysqldump $DBNAME $BLOCKCHAIN_TABLES --skip-quote-names | pv --progress --size $SIZE_BYTES > "$ARONODE_PATH/$BACKUP_FILENAME.sql"
    echo "$CHECK_CHAR backup exported."

    echo "$TASK_CHAR compressing blockchain backup to $ARONODE_PATH/$BACKUP_FILENAME.sql.gz (PLEASE WAIT) ..."
    pv "$ARONODE_PATH/$BACKUP_FILENAME.sql" | pigz -f > "$ARONODE_PATH/$BACKUP_FILENAME.sql.gz"
    if [ -f "$ARONODE_PATH/$BACKUP_FILENAME.sql" ]; then
        rm "$ARONODE_PATH/$BACKUP_FILENAME.sql"
    fi
    echo "$CHECK_CHAR backup compressed."
}

importDb() {

    # get third argument (optional) for sql filename
    if [[ "$ARG_THREE" == "" ]]; then
        BACKUP_FILEPATH="$ARONODE_PATH/$BACKUP_FILENAME.sql.gz"
    else
        BACKUP_FILEPATH="$ARG_THREE"
    fi

    # add current path if not full path
    #if [[ ! $BACKUP_FILEPATH == /* ]]; then
    #    BACKUP_FILEPATH="$ARONODE_PATH/$BACKUP_FILENAME"
    #fi


    # remove .gz from filename
    BACKUP_FILEPATH_SQL=`echo $BACKUP_FILEPATH | sed -e 's/\(\.gz\)*$//g'`

    if [ -f $BACKUP_FILEPATH ]; then

        # clean db
        nodeEmptyChain

        # FIX BUG: foreign key restraint on import of dump
        CMD_BEFORE_IMPORT=" SET foreign_key_checks=0; "
        CMD_AFTER_IMPORT=" SET foreign_key_checks=1; "

        # 2) pv unzip
        echo "$INFO_CHAR extracting blockchain from dump (PLEASE WAIT) ..."
        gunzip -c --keep "$BACKUP_FILEPATH" | pv > "$BACKUP_FILEPATH_SQL"

        # 3) append top/bottom commands
        echo "$INFO_CHAR adding foreign_key_checks fix ..."
        sed -i "1s/^/$CMD_BEFORE_IMPORT\n/" "$BACKUP_FILEPATH_SQL"
        echo $CMD_AFTER_IMPORT >> "$BACKUP_FILEPATH_SQL"
        # 4) import sql.gz file into mysql database w/ progress bar
        echo "$INFO_CHAR importing blockchain dump (PLEASE WAIT) ..."
        pv "$BACKUP_FILEPATH_SQL" | sudo -H mysql  -D $DBNAME

        # 5) cleanup
        if [ -f "$BACKUP_FILEPATH_SQL" ]; then
            rm "$BACKUP_FILEPATH_SQL"
        fi

        echo "$CHECK_CHAR backup restored."

    else
        echo "$ERROR_CHAR $BACKUP_FILEPATH not found. Nothing to import."
        exitAsError
    fi


}


removeRebuildDaily() {
    # make sure in script path
    cd $ARONODE_PATH

    # if any dumps found; delete them
    if ls $LOCAL_SNAPTEMP* 1> /dev/null 2>&1; then
        # only delete them if variable is not empty; ie. dont "rm *"
        [[ ! -z "$LOCAL_SNAPTEMP" ]] && rm -v $LOCAL_SNAPTEMP*
    fi

}

# for custom import try "backup/import" instead
nodeRebuild() {

    # make sure in script path
    cd $ARONODE_PATH

    # check if mainnet ONLY; ERROR if testnet.
    #nodeCheckConfigMode
    if [[ "$NODE_CONFIG_MODE" != "mainnet" ]]; then
        echo "$CHECK_CHAR Arionum node is set to testnet. Starting db from scratch."
    else

        # 1) get latest snapshot
        if [ ! -f $LOCAL_SNAPSHOT ]; then
            echo "$INFO_CHAR downloading latest daily snapshot of blockchain ..."
            curl --progress-bar -o $LOCAL_SNAPSHOT $REMOTE_SNAPSHOT
        else
            echo "$INFO_CHAR snapshot $LOCAL_SNAPSHOT exists locally; using it ..."
        fi

        # FIX BUG: foreign key restraint on import of dump required
        CMD_BEFORE_IMPORT=" SET foreign_key_checks=0; "
        CMD_AFTER_IMPORT=" SET foreign_key_checks=1; "

        # 2) pv unzip
        echo "$INFO_CHAR extracting daily snapshot of blockchain (PLEASE WAIT) ..."
        gunzip -c --keep $LOCAL_SNAPSHOT | pv > $LOCAL_SNAPTEMP

        # 3) append top/bottom commands
        echo "$INFO_CHAR adding foreign_key_checks fix ..."
        sed -i "1s/^/$CMD_BEFORE_IMPORT\n/" $LOCAL_SNAPTEMP
        echo $CMD_AFTER_IMPORT >> $LOCAL_SNAPTEMP
        # 4) import sql.gz file into mysql database w/ progress bar
        echo "$INFO_CHAR importing daily snapshot of blockchain  (PLEASE WAIT) ..."
        pv $LOCAL_SNAPTEMP | sudo -H mysql  -D $DBNAME

        # 5) cleanup
        if [ -f "$LOCAL_SNAPTEMP" ]; then
            rm "$LOCAL_SNAPTEMP"
        fi

    fi

}

nodeEmptyChain() {
    echo "$INFO_CHAR Emptying blockchain data: ${DBNAME} tables (PLEASE WAIT) ..."

    # FIX BUG: foreign key restraint on import of dump
    CMD_BEFORE_IMPORT=" SET foreign_key_checks=0; "
    CMD_AFTER_IMPORT=" SET foreign_key_checks=1; "

    # clear sanity or this will fail
    killSanity
    removeSanityLock

    # use arionum utility
    PWD=`pwd`
    cd $DOMAINROOT
    CMD=`php -f util.php clean`
    CMD="${CMD//[$'\t\r\n']}"
    echo "$INFO_CHAR $CMD"
    cd $PWD

    # doing it manually
    #ARRAY=($BLOCKCHAIN_TABLES)
    #for TABLE in "${ARRAY[@]}"
    #do
        #echo "$INFO_CHAR Truncating table '$TABLE' ..."
        #sudo -H mysql -e "$CMD_BEFORE_IMPORT TRUNCATE TABLE $DBNAME.$TABLE; $CMD_AFTER_IMPORT"
    #done
}
peersReset() {
    echo "$INFO_CHAR Emptying peers table in database."
    # delete mysql tables
    sudo -H mysql -e "TRUNCATE TABLE $DBNAME.peers;"
}
nodeDropDb() {
    echo "$INFO_CHAR Dropping database: ${DBNAME}"
    # delete mysql tables
    sudo -H mysql  -e "DROP DATABASE IF EXISTS ${DBNAME};"
    sudo -H mysql  -e "CREATE DATABASE ${DBNAME} /*\!40100 DEFAULT CHARACTER SET utf8mb4 */;"
}

nodeRemove() {

    echo ""
    read -p "WARNING: This will purge ALL Nginx|Php-fpm|Mysql AND Arionum content. Continue? (yes|no): " USER_REMOVE_CONTINUE
    if ! [[ "$USER_REMOVE_CONTINUE" == "yes" ]]; then
        echo -e "$ERROR_CHAR You did not type 'yes'. Halting setup.\n"
        exitAsError
    fi

    echo "$INFO_CHAR Starting removal of Arionum node ..."

    # stop services
    #service nginx stop
    #service $PHPFPM_SERVICE stop

    # remove/purge nginx/php-fpm
    apt-get -qq --purge remove nginx
    apt-get -qq --purge remove $PACKAGES_PHP -y

    # remove/purge mysql
    packagePurgeMysql

    apt-get -qq autoremove -y
    apt-get -qq autoclean -y

    # delete $DOMAINROOT contents
    #nodeFindDomainRoot
    if [ -d $DOMAINROOT ]; then
        rm -Rf $DOMAINROOT
        echo "$CHECK_CHAR $DOMAINROOT directory removed."
    else
        echo "$INFO_CHAR $DOMAINROOT webroot directory not found. Nothing to remove or skipped."
    fi
}

nodeTestnetConfig() {
    #nodeFindDomainRoot
    if [ $DOMAINROOT != false ]; then
        # set $_config['testnet'] = true;
        ARONODE_CONFIG="$DOMAINROOT/$WEBCONFIGPATH"
        if [ -f $ARONODE_CONFIG ]; then
            sed -i -re "s/('testnet'\] = )([trueTRUEfalsFALS]*);/\1true;/" $ARONODE_CONFIG
            echo "$CHECK_CHAR Config set to 'testnet'"
        else
            echo "$ERROR_CHAR $ARONODE_CONFIG not found. testnet not set."
        fi
    else
        echo "$ERROR_CHAR $DOMAINROOT not found. Nothing to remove."
    fi
}

nodeMainnetConfig() {

    # check RAM
    checkRAM
    if [[ $RAMTOTAL -lt 1800 ]]; then
        echo ""
        read -p "WARNING: Detected < 2GB RAM. Node may have issues syncing beyond block 10800. Continue? (yes|no): " USER_RAM_CONTINUE
        if ! [[ "$USER_RAM_CONTINUE" == "yes" ]]; then
            echo -e "$ERROR_CHAR You did not type 'yes'. Halting setup.\n"
            exitAsError
        fi
    fi

    #nodeFindDomainRoot
    if [ $DOMAINROOT != false ]; then
        # set $_config['testnet'] = false;
        ARONODE_CONFIG="$DOMAINROOT/$WEBCONFIGPATH"
        if [ -f $ARONODE_CONFIG ]; then
            sed -i -re "s/('testnet'\] = )([trueTRUEfalsFALS]*);/\1false;/" $ARONODE_CONFIG
            echo "$CHECK_CHAR Config set to 'mainnet'"
        else
            echo "$ERROR_CHAR $ARONODE_CONFIG file not found. mainnet not set."
        fi
    else
        echo "$ERROR_CHAR $DOMAINROOT not found. Nothing to remove."
    fi
}

nodeStatus() {
    upNginx
    if [ "$UP_NGINX" == "yes" ]; then
        echo "$CHECK_CHAR   nginx: OK"
    else
        echo "$ERROR_CHAR   nginx: FAIL"
    fi

    upPhp
    if [ "$UP_PHP" == "yes" ]; then
        checkPhpVersion
        echo "$CHECK_CHAR php-fpm: OK ($PHP_VERSION_CLI)"
    else
        echo "$ERROR_CHAR php-fpm: FAIL ($PHP_VERSION_CLI)"
    fi

    upMysql
    if [ "$UP_MYSQL" == "yes" ]; then
        echo "$CHECK_CHAR   mysql: OK"
    else
        echo "$ERROR_CHAR   mysql: FAIL"
    fi


    # check for 200 response or not
    echo "$TASK_CHAR Checking node status ..."
    STATUS=$(curl --connect-timeout 10 --max-time 15 -SsI http://127.0.0.1:80/ | head -n 1 | cut -d$' ' -f2)
    if [ "$STATUS" == "200" ]; then
        echo "$CHECK_CHAR http://127.0.0.1:80/ => 200 response: OK"
        echo "$INFO_CHAR Querying API for current block http://127.0.0.1:80/api.php?q=currentBlock"
        echo "$INFO_CHAR Querying API for node version  http://127.0.0.1:80/api.php?q=version"
        CURRENT_BLOCK=$(curl -Ss "http://127.0.0.1:80/api.php?q=currentBlock" | awk -F'"height":' '{print $2}' | cut -d$',' -f1 | tr -d '[:space:]')

        # check if number and > 0 block
        re='^[0-9]+$'
        if [[ $CURRENT_BLOCK =~ $re && $CURRENT_BLOCK -gt 0 ]]; then
            # print version
            VERSION_NODE=$(curl -Ss "http://127.0.0.1:80/api.php?q=version" | awk -F'"data":' '{print $2}' | cut -d$',' -f1 | tr -d '[:space:]')
            echo "$CHECK_CHAR  Node Version: $VERSION_NODE"

            echo "$CHECK_CHAR Current Block: $CURRENT_BLOCK"
            # get time behind
            BLOCKDATE=$(curl -Ss "http://127.0.0.1:80/api.php?q=getBlock&height=$CURRENT_BLOCK" | awk -F'"date":' '{print $2}' | cut -d$',' -f1 | tr -d '[:space:]')
            DATER=`date +%s`
            BEHIND_SECONDS=`expr $DATER - $BLOCKDATE`
            #BEHIND_HOURS=`expr $BEHIND_MINS / 60`
            #BEHIND_DAYS=`expr $BEHIND_HOURS / 24`
            if [ $BEHIND_SECONDS -lt 60 ]; then
                BEHIND_FORMAT=`echo $BEHIND_SECONDS`
                BEHIND_LABEL="seconds"
            fi
            if [ $BEHIND_SECONDS -gt 60 ]; then
                BEHIND_MINS=`expr $BEHIND_SECONDS / 60`
                BEHIND_FORMAT=`echo $BEHIND_MINS`
                BEHIND_LABEL="minutes"
            fi
            if [ $BEHIND_SECONDS -gt 14400 ]; then
                BEHIND_HOURS=`expr $BEHIND_SECONDS / 60 / 60`
                BEHIND_FORMAT=`echo $BEHIND_HOURS`
                BEHIND_LABEL="hours"
            fi
            if [ $BEHIND_SECONDS -gt 86400 ]; then
                BEHIND_DAYS=`expr $BEHIND_SECONDS / 60 / 60 / 24`
                BEHIND_FORMAT=`echo $BEHIND_DAYS`
                BEHIND_LABEL="days"
            fi
            echo -e "$CHECK_CHAR   Node Behind: $BEHIND_FORMAT $BEHIND_LABEL"

        else
            echo ""
            echo -e "$ERROR_CHAR Could not query api for current block. Node not initialized/syncing/up?"
            echo ""

            echo -e "$INFO_CHAR TROUBLESHOOTING STEPS ..."
            echo -e "$INFO_CHAR In your web browser, visit http://YOURPUBLICIPADDRESS to initialize."
            echo -e "$INFO_CHAR Alternatively, visit http://YOURCUSTOMDOMAIN to initialize."
            echo -e "$INFO_CHAR Try running 'status' a few times to load initial blocks."
            echo -e "$INFO_CHAR Try running 'restart' a few times."
            echo -e "$INFO_CHAR Try running 'sync' to run sanity manually to monitor progress."
            echo -e "$INFO_CHAR Try running 'rebuild' to sync to a remote daily snapshot."

            echo -e "$INFO_CHAR If you think its bug, submit issue to https://github.com/KyleFromOhio/arionum-scripts/issues"
        fi
    else
        echo ""
        echo -e "$ERROR_CHAR node status: FAIL (timeout or response != 200)"
        echo -e "$ERROR_CHAR could not query http://127.0.0.1:80/"
        echo -e "$ERROR_CHAR Could not query api for current block. Node not initialized/syncing/up?"
        echo ""


            echo -e "$INFO_CHAR TROUBLESHOOTING STEPS ..."
            echo -e "$INFO_CHAR In your web browser, visit http://YOURPUBLICIPADDRESS to initialize."
            echo -e "$INFO_CHAR Alternatively, visit http://YOURCUSTOMDOMAIN to initialize."
            echo -e "$INFO_CHAR Try running 'status' a few times to load initial blocks."
            echo -e "$INFO_CHAR Try running 'restart' a few times."
            echo -e "$INFO_CHAR Try running 'sync' to run sanity manually to monitor progress."
            echo -e "$INFO_CHAR Try running 'rebuild' to sync to a remote daily snapshot."

        echo -e "$ERROR_CHAR If you think its bug, submit issue to https://github.com/KyleFromOhio/arionum-scripts/issues"
    fi
}

nodeDiff() {
    echo "$TASK_CHAR nodeDiff() Checking git for available updates ..."
    #nodeFindDomainRoot
    PWD=`pwd`
    cd $DOMAINROOT
    git fetch origin
    git diff --color master origin/master
    echo "$CHECK_CHAR Available updates (if any) have been printed above this line."
    cd $PWD

}

nodeChangeHostname() {
    # Prompt user for IP; auto detect it
    DETECT_IP4=$(/sbin/ip -o -4 addr list eth0 | awk '{print $4}' | cut -d/ -f1 | head -n1)
    echo ""
    echo "$INFO_CHAR This will update the hostname setting in the node db config."
    echo "$INFO_CHAR Other peers will see this hostname in their peers list."
    echo "$INFO_CHAR You may enter a domain name but it must resolve to your server or risk failing to sync."

    # TDOO: read -p "QUESTION: Do you want your node use a domain OR an IP4 address? (ip|domain): " USER_IPORDOMAIN
    # TODO: check if user enter ip or domain as option
    # TODO: if entered 'ip' ask for it
    # TODO: if entered 'domain' ask for it
    read -p "QUESTION: Enter new node hostname OR public IP4 address ($DETECT_IP4): " NEWHOSTNAME
    if [[ "$NEWHOSTNAME" == "" ]]; then
        NEWHOSTNAME="$DETECT_IP4"
    fi
    # check DOMAIN/IP is valid; [a-z0-9\-\.]; start and end with a letter; replace any capital letters with lowercase automatically.
    NEWHOSTNAME=`echo "$NEWHOSTNAME" | awk '{print tolower($0)}'`
    # strip http:// from beginning
    NEWHOSTNAME=`echo "$NEWHOSTNAME" | sed -e "s/^http:\/\///"`
    NEWHOSTNAME=`echo "$NEWHOSTNAME" | sed -e "s/^https:\/\///"`

    # TODO: detect if private ip address
    # TODO: detect if valid (only [#.] )
    # TODO: etect if valid domain
    #REGEX='^[a-z]+[a-z0-9\-\.]{1,252}[a-z]{2,24}$';
    #if ! [[ "$DOMAIN" =~ $REGEX ]]; then
    #    echo "$ERROR_CHAR Invalid domain entered ..."
    #    exitAsError
    #fi
    #echo "$ERROR_CHAR Invalid ip4 entered ..."
    #exitAsError

    echo "$INFO_CHAR You entered: $NEWHOSTNAME"
    echo "$INFO_CHAR We detected: $DETECT_IP4"
    if ! [[ "$DETECT_IP4" == "$NEWHOSTNAME" ]]; then
        read -p "QUESTION: hostname you entered and IP we detected do NOT match. Continue anyways? (yes|no) " USER_IP4_CONTINUE
        if ! [[ "$USER_IP4_CONTINUE" == "yes" ]]; then
            echo -e "$ERROR_CHAR You did not type 'yes'. Halting setup.\n"
            exitAsError
        fi
    fi
    # update config in db with new hosname via mysql
    sudo -H mysql  -e "UPDATE ${DBNAME}.config SET val='http://${NEWHOSTNAME}' WHERE cfg='hostname';"
}
killSanity() {
    CMD=`pkill -f sanity > /dev/null`
}
queueSanity() {
    sudo -H mysql  -e "UPDATE ${DBNAME}.config SET val=0 WHERE cfg='sanity_last' LIMIT 1;"
}
runSanity() {
    echo "$TASK_CHAR Running sanity.php ..."
    # use arionum utility
    PWD=`pwd`
    cd $DOMAINROOT
    php -f sanity.php
    cd $PWD
    echo "$INFO_CHAR $CMD"
    echo "$CHECK_CHAR sanity attempt complete"

}
checkRAM() {
    RAMTOTAL=$(free -m | awk '/^Mem:/{print $2}')
}

# determine wheher user entered mainnet or testnet
nodeFindDomainRoot
nodeCheckConfigMode

# yell at user if they entered wrong CONFIG_MODE for the call
if [ ! "$NODE_CONFIG_MODE" == "$ARG_CONFIG_MODE" ]; then
    if [[
        "$ARG_CALL" == "upgrade" ||
        "$ARG_CALL" == "rebuild" ||
        "$ARG_CALL" == "change"
    ]]; then
        echo -e "$ERROR_CHAR Wrong mode entered. Config detected is $NODE_CONFIG_MODE. You entered $ARG_CONFIG_MODE\n"
        exitAsError
    fi
fi

# Determine 2nd argument action
case "$ARG_CALL" in
    "backup")
        # stop nginx/php-fpm services; leave mysql on
        nodeStop

        backupDb
        nodeStart
        ;;
    "change")
        nodeChangeHostname

        nodeStop
        flagDbUpdate
        removeSanityLock
        nodeStart

        queueSanity
        nodeRefresh
        ;;
    "diff")
        nodeDiff
        ;;
    "firewall")
        if [[ -z "3" || ( "$3" != "install" && "$3" != "remove" && "$3" != "on" && "$3" != "off") ]]; then
            echo "$ERROR_CHAR Third argument must be either install, remove, on or off."
        fi

        case "$3" in
            "install")
                hardenFirewall
                ;;
            "remove")
                removeFirewall
                ;;
            "on")
                enableFirewall
                ;;
            "off")
                disableFirewall
                ;;
        esac
        ;;
    "fix")
        fix020
        ;;
    "import")
        # optional; get filename argument
        if [[ -z "3" || "$3" == "" ]]; then
            ARG_THREE=""
        else
            ARG_THREE=$3
        fi

        # stop nginx/php-fpm services; leave mysql on
        nodeStop

        importDb

        flagDbUpdate
        removeSanityLock
        nodeStart
        queueSanity

        nodeRefresh
        ;;
    "install")
        startLogging
        symlinkAronode
        nodeInstall
        ;;
    "mysql")
        # get third argument <set|get|restart>
        case $3 in
            "get")
                MYSQL_VARIABLE=$4
                mysqlGetConfig
            ;;
            "set")
                MYSQL_VARIABLE=$4
                MYSQL_VALUE=$5
                mysqlSetConfig
            ;;
            "restart")
                nodeStopDb
                nodeStart
            ;;
            *)
            echo "$ERROR_CHAR Invalid command. Missing arguments. See help."
            exitAsError
            ;;
        esac
        ;;
    "peers")
        # get third argument <set|get|restart>
        case $3 in
            "reset")
                peersReset
            ;;
            *)
            echo "$ERROR_CHAR Invalid command. Missing arguments. See help."
            exitAsError
            ;;
        esac
        ;;
    "pop")
        startLogging

        # get third argument (optional) for # of blocks to pop
        POP_COUNT=1
        case $3 in
            ''|*[!0-9]*) POP_COUNT=1 ;;
            *) POP_COUNT=$3 ;;
        esac

        # pop X blocks from db
        echo "$INFO_CHAR Popping $POP_COUNT records."
        PWD=`pwd`
        cd $DOMAINROOT
        php -f util.php pop $POP_COUNT
        cd $PWD

        nodeStop
        removeSanityLock

        nodeStart
        queueSanity

        nodeRefresh
        ;;
    "rebuild")
        # optional; get 3rd argument
        if [[ -z "3" || "$3" == "" ]]; then
            ARG_THREE=""
        else
            ARG_THREE=$3
        fi

        startLogging
        # stop nginx/php-fpm services; leave mysql on
        nodeStop

        nodeEmptyChain

        # get third argument (optional) to delete daily dump download
        if [[ "$ARG_THREE" == "latest" ]]; then
            removeRebuildDaily
        fi
        nodeRebuild

        flagDbUpdate
        removeSanityLock

        nodeStart
        queueSanity

        nodeRefresh
        ;;
    "remove")
        startLogging
        nodeStop
        nodeRemove
        ;;
    "require")
        packageInstallGeneral
        ;;
    "reset")
        startLogging

        # stop nginx/php-fpm services; leave mysql on
        nodeStop

        if [[ "$ARG_CONFIG_MODE" == "mainnet" ]]; then
            nodeMainnetConfig
            nodeEmptyChain
        fi
        if [[ "$ARG_CONFIG_MODE" == "testnet" ]]; then
            nodeTestnetConfig
            nodeEmptyChain
        fi
        flagDbUpdate
        removeSanityLock

        nodeStart
        queueSanity

        nodeRefresh
        ;;
    "restart")
        nodeStop
        killSanity
        removeSanityLock
        nodeStopDb
        nodeStart
        queueSanity
        nodeStatus
        ;;
    "resync-accounts")
        startLogging
        echo ""
        read -p "WARNING: Will check ALL account balances & may take a long time. Continue? (yes|no): " RESYNCACCNT_CONTINUE
        if ! [[ "$RESYNCACCNT_CONTINUE" == "yes" ]]; then
            echo -e "$ERROR_CHAR You did not type 'yes'. Halting.\n"
            exitAsError
        fi
        # run resync-accounts
        echo "$INFO_CHAR Resyncing accounts ... (PLEASE WAIT) ..."
        PWD=`pwd`
        cd $DOMAINROOT
        php -f util.php resync-accounts
        cd $PWD
        ;;
    "status")
        nodeStatus
        ;;
    "stop")
        killSanity
        nodeStop
        ;;
    "sync")
        killSanity
        queueSanity
        removeSanityLock
        runSanity
        ;;
    "upgrade")
        gitPullAronode
        symlinkAronode
        startLogging

        packageUpgradePhp
        nodeStop
        hardenMysql
        nodeStopDb

        nodeUpgrade
        fixNodePermissions

        nodeStop
        flagDbUpdate
        removeSanityLock

        nodeStart
        queueSanity

        nodeRefresh
        ;;
    "update")
        gitPullAronode
        symlinkAronode
        nodeUpdate
        fixNodePermissions
        ;;
    "usage|help|h|-h|--help")
        usage
        ;;
    "version")
        aronodeCheckVersion
        exit 0
        ;;
esac

echo -e "\n$END_LOG_MSG"
echo -e "$CHECK_CHAR SCRIPT COMPLETE. For more guides, visit www.aro.wiki"
echo -e ""

exit 0
